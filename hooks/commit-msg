#!/bin/bash
# Ralph commit-msg hook
# Automatically updates CHANGELOG.md based on conventional commit messages
#
# Install: ./hooks/install-hooks.sh
# Or: cp hooks/commit-msg .git/hooks/commit-msg && chmod +x .git/hooks/commit-msg

COMMIT_MSG_FILE="$1"
COMMIT_MSG=$(cat "$COMMIT_MSG_FILE")

# Get the repo root
REPO_ROOT=$(git rev-parse --show-toplevel)
CHANGELOG="$REPO_ROOT/CHANGELOG.md"

# Skip if this is a merge commit, amend, or release commit
if echo "$COMMIT_MSG" | grep -qE -- "^Merge |^Release v|^\[skip changelog\]"; then
  exit 0
fi

# Skip if CHANGELOG.md doesn't exist
if [ ! -f "$CHANGELOG" ]; then
  exit 0
fi

# Parse conventional commit type and extract the message
# Format: type(scope): description  OR  type: description
if echo "$COMMIT_MSG" | grep -qE -- "^(feat|fix|docs|style|refactor|perf|test|chore|build|ci)(\(.+\))?!?:"; then
  # Extract type (with optional ! for breaking)
  TYPE=$(echo "$COMMIT_MSG" | sed -E 's/^([a-z]+)(\(.+\))?(!)?:.*/\1\3/')

  # Extract the first line (summary)
  SUMMARY=$(echo "$COMMIT_MSG" | head -1 | sed -E 's/^[a-z]+(\(.+\))?!?:\s*//')

  # Map commit type to changelog section
  case "$TYPE" in
    feat|feat!)
      SECTION="Added"
      ;;
    fix|fix!)
      SECTION="Fixed"
      ;;
    docs)
      SECTION="Documentation"
      ;;
    perf)
      SECTION="Performance"
      ;;
    refactor)
      SECTION="Changed"
      ;;
    chore|build|ci|style|test)
      # Skip these types - they don't need changelog entries
      exit 0
      ;;
    *)
      SECTION="Changed"
      ;;
  esac

  # Check if there's a breaking change
  if echo "$COMMIT_MSG" | grep -qE -- "^BREAKING CHANGE:|^[a-z]+(\(.+\))?!:"; then
    SECTION="Breaking Changes"
  fi

  # Check if this entry already exists (avoid duplicates on amend)
  if grep -qF -- "- $SUMMARY" "$CHANGELOG" 2>/dev/null; then
    exit 0
  fi

  # Create entry line
  ENTRY="- $SUMMARY"

  # Use Python for reliable changelog manipulation (available on macOS)
  python3 << EOF
import re

with open('$CHANGELOG', 'r') as f:
    content = f.read()

section = "$SECTION"
entry = "$ENTRY"

# Find the [Unreleased] section
unreleased_match = re.search(r'^## \[Unreleased\].*?(?=^## \[|\Z)', content, re.MULTILINE | re.DOTALL)

if not unreleased_match:
    # No unreleased section found
    exit(0)

unreleased = unreleased_match.group()
unreleased_start = unreleased_match.start()
unreleased_end = unreleased_match.end()

# Check if our section exists in unreleased
section_pattern = rf'^### {re.escape(section)}$'
section_match = re.search(section_pattern, unreleased, re.MULTILINE)

if section_match:
    # Add entry after section header
    insert_pos = unreleased_start + section_match.end()
    new_content = content[:insert_pos] + '\n' + entry + content[insert_pos:]
else:
    # Need to add new section - find where to insert it
    # Add before the next version or at end of unreleased
    # Find the position just before the next ## [ or end of unreleased
    next_version = re.search(r'\n(?=## \[(?!Unreleased))', content[unreleased_start:])
    if next_version:
        insert_pos = unreleased_start + next_version.start()
    else:
        insert_pos = len(content)

    new_section = f'\n### {section}\n{entry}\n'
    new_content = content[:insert_pos] + new_section + content[insert_pos:]

with open('$CHANGELOG', 'w') as f:
    f.write(new_content)
EOF

  # Stage the changelog update
  git add "$CHANGELOG"
fi

exit 0
