package worker

import (
	"os"
	"os/exec"
	"path/filepath"
	"strings"
	"testing"

	"github.com/arvesolland/ralph/internal/git"
	"github.com/arvesolland/ralph/internal/plan"
	"github.com/arvesolland/ralph/internal/worktree"
)

func TestIsGHInstalled(t *testing.T) {
	// This is an existence check - we just verify it returns a boolean
	// and doesn't panic
	result := isGHInstalled()
	// We can't assert the value since it depends on the test environment
	t.Logf("gh installed: %v", result)
}

func TestExtractPRURL(t *testing.T) {
	tests := []struct {
		name     string
		input    string
		expected string
	}{
		{
			name:     "standard URL",
			input:    "https://github.com/arvesolland/ralph/pull/123",
			expected: "https://github.com/arvesolland/ralph/pull/123",
		},
		{
			name:     "URL in text",
			input:    "Created PR: https://github.com/owner/repo/pull/456\nDone.",
			expected: "https://github.com/owner/repo/pull/456",
		},
		{
			name:     "no URL",
			input:    "Something went wrong",
			expected: "",
		},
		{
			name:     "URL with different owner/repo",
			input:    "https://github.com/some-org/some-repo/pull/789",
			expected: "https://github.com/some-org/some-repo/pull/789",
		},
		{
			name:     "multiple URLs (returns first)",
			input:    "First: https://github.com/a/b/pull/1 Second: https://github.com/c/d/pull/2",
			expected: "https://github.com/a/b/pull/1",
		},
		{
			name:     "similar but not PR URL",
			input:    "https://github.com/owner/repo/issues/123",
			expected: "",
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			result := extractPRURL(tt.input)
			if result != tt.expected {
				t.Errorf("extractPRURL(%q) = %q, want %q", tt.input, result, tt.expected)
			}
		})
	}
}

func TestBuildPRBody(t *testing.T) {
	t.Run("basic plan", func(t *testing.T) {
		p := &plan.Plan{
			Name:  "test-feature",
			Tasks: nil,
		}

		body := buildPRBody(p)

		// Verify required elements
		if !strings.Contains(body, "## Summary") {
			t.Error("body should contain Summary header")
		}
		if !strings.Contains(body, "Implements: test-feature") {
			t.Error("body should contain plan name")
		}
		if !strings.Contains(body, "Generated by [Ralph]") {
			t.Error("body should contain Ralph attribution")
		}
	})

	t.Run("plan with tasks", func(t *testing.T) {
		p := &plan.Plan{
			Name: "multi-task",
			Tasks: []plan.Task{
				{Text: "Task 1", Complete: true},
				{Text: "Task 2", Complete: true},
				{Text: "Task 3", Complete: false},
			},
		}

		body := buildPRBody(p)

		// Should include task counts
		if !strings.Contains(body, "Tasks completed: 2/3") {
			t.Errorf("body should contain task counts, got: %s", body)
		}
	})

	t.Run("plan with nested tasks", func(t *testing.T) {
		p := &plan.Plan{
			Name: "nested-tasks",
			Tasks: []plan.Task{
				{
					Text:     "Parent task",
					Complete: true,
					Subtasks: []plan.Task{
						{Text: "Subtask 1", Complete: true},
						{Text: "Subtask 2", Complete: false},
					},
				},
			},
		}

		body := buildPRBody(p)

		// Should count all tasks including subtasks (1 parent + 2 subtasks = 3, 2 complete)
		if !strings.Contains(body, "Tasks completed: 2/3") {
			t.Errorf("body should count nested tasks, got: %s", body)
		}
	})
}

func TestPRURLRegex(t *testing.T) {
	validURLs := []string{
		"https://github.com/owner/repo/pull/1",
		"https://github.com/a/b/pull/123",
		"https://github.com/some-org/some-repo/pull/99999",
	}

	for _, url := range validURLs {
		if !prURLRegex.MatchString(url) {
			t.Errorf("prURLRegex should match %q", url)
		}
	}

	invalidURLs := []string{
		"http://github.com/owner/repo/pull/1", // http not https
		"https://github.com/owner/repo/issues/1",
		"https://github.com/owner/repo/pull/",    // no number
		"https://gitlab.com/owner/repo/pull/123", // not github
	}

	for _, url := range invalidURLs {
		if prURLRegex.MatchString(url) {
			t.Errorf("prURLRegex should not match %q", url)
		}
	}
}

func TestLogManualPRInstructions(t *testing.T) {
	// Just verify it doesn't panic
	p := &plan.Plan{
		Name:   "test-plan",
		Branch: "feat/test-plan",
	}

	// Capture that it runs without error
	logManualPRInstructions(p)
}

// TestCompletePR_Integration tests the full PR completion workflow
// This test requires a real git repository with a remote
func TestCompletePR_Integration(t *testing.T) {
	if testing.Short() {
		t.Skip("skipping integration test in short mode")
	}

	// Check if gh is installed
	if !isGHInstalled() {
		t.Skip("gh CLI not installed, skipping integration test")
	}

	// This test would require:
	// 1. A real git repository with a remote
	// 2. GitHub authentication configured
	// We skip actual PR creation as it would modify real repositories
	t.Skip("full integration test requires real repository setup")
}

// TestPushBranch tests the branch push functionality using a mock
func TestPushBranch(t *testing.T) {
	// Create a mock Git implementation for testing
	mockGit := &mockGitForCompletion{
		pushError: nil,
	}

	err := pushBranch(mockGit, "feat/test")
	if err != nil {
		t.Errorf("pushBranch() error = %v, want nil", err)
	}

	if mockGit.pushedBranch != "feat/test" {
		t.Errorf("pushBranch() pushed branch = %q, want %q", mockGit.pushedBranch, "feat/test")
	}
}

func TestPushBranch_Error(t *testing.T) {
	mockGit := &mockGitForCompletion{
		pushError: ErrPushFailed,
	}

	err := pushBranch(mockGit, "feat/test")
	if err == nil {
		t.Error("pushBranch() should return error when push fails")
	}
}

// mockGitForCompletion is a minimal mock for testing completion functions
type mockGitForCompletion struct {
	git.Git
	pushError    error
	pushedBranch string
	workDir      string
}

func (m *mockGitForCompletion) PushWithUpstream(remote, branch string) error {
	m.pushedBranch = branch
	return m.pushError
}

func (m *mockGitForCompletion) WorkDir() string {
	return m.workDir
}

// TestCreatePR_GHNotInstalled tests graceful handling when gh is not available
func TestCreatePR_GHNotInstalled(t *testing.T) {
	// Temporarily modify PATH to ensure gh is not found
	originalPath := os.Getenv("PATH")
	defer os.Setenv("PATH", originalPath)

	// Set PATH to empty to simulate gh not being installed
	os.Setenv("PATH", "")

	p := &plan.Plan{
		Name:   "test-plan",
		Branch: "feat/test-plan",
	}

	_, err := createPR(p, "/tmp")
	if err != ErrGHNotInstalled {
		t.Errorf("createPR() error = %v, want ErrGHNotInstalled", err)
	}
}

// TestCompletePR_MockGH tests the completion workflow with a mock gh script
func TestCompletePR_MockGH(t *testing.T) {
	if testing.Short() {
		t.Skip("skipping integration test in short mode")
	}

	// Create a temporary directory for the mock gh script
	tmpDir, err := os.MkdirTemp("", "completion-test-*")
	if err != nil {
		t.Fatalf("failed to create temp dir: %v", err)
	}
	defer os.RemoveAll(tmpDir)

	// Create a mock gh script that outputs a PR URL
	mockGH := filepath.Join(tmpDir, "gh")
	mockScript := `#!/bin/bash
echo "https://github.com/test/repo/pull/123"
`
	if err := os.WriteFile(mockGH, []byte(mockScript), 0755); err != nil {
		t.Fatalf("failed to write mock gh: %v", err)
	}

	// Modify PATH to include our mock
	originalPath := os.Getenv("PATH")
	defer os.Setenv("PATH", originalPath)
	os.Setenv("PATH", tmpDir+":"+originalPath)

	// Create a git repo for the worktree
	repoDir := filepath.Join(tmpDir, "repo")
	if err := os.MkdirAll(repoDir, 0755); err != nil {
		t.Fatalf("failed to create repo dir: %v", err)
	}

	// Initialize git repo
	cmd := exec.Command("git", "init")
	cmd.Dir = repoDir
	if err := cmd.Run(); err != nil {
		t.Fatalf("failed to init git repo: %v", err)
	}

	// Create initial commit
	testFile := filepath.Join(repoDir, "test.txt")
	if err := os.WriteFile(testFile, []byte("test"), 0644); err != nil {
		t.Fatalf("failed to write test file: %v", err)
	}

	cmd = exec.Command("git", "add", ".")
	cmd.Dir = repoDir
	if err := cmd.Run(); err != nil {
		t.Fatalf("failed to git add: %v", err)
	}

	cmd = exec.Command("git", "commit", "-m", "initial")
	cmd.Dir = repoDir
	cmd.Env = append(os.Environ(),
		"GIT_AUTHOR_NAME=Test",
		"GIT_AUTHOR_EMAIL=test@test.com",
		"GIT_COMMITTER_NAME=Test",
		"GIT_COMMITTER_EMAIL=test@test.com",
	)
	if err := cmd.Run(); err != nil {
		t.Fatalf("failed to git commit: %v", err)
	}

	// Test plan and worktree
	p := &plan.Plan{
		Name:   "test-feature",
		Branch: "feat/test-feature",
	}
	wt := &worktree.Worktree{
		Path:     repoDir,
		Branch:   "feat/test-feature",
		PlanName: "test-feature",
	}

	// Mock git that succeeds for push
	mockGit := &mockGitForCompletion{
		pushError: nil,
		workDir:   repoDir,
	}

	// Run the PR completion (with our mock gh)
	prURL, err := CompletePR(p, wt, mockGit)
	if err != nil {
		t.Errorf("CompletePR() error = %v", err)
	}

	if prURL != "https://github.com/test/repo/pull/123" {
		t.Errorf("CompletePR() prURL = %q, want %q", prURL, "https://github.com/test/repo/pull/123")
	}
}

func TestCompletionErrors(t *testing.T) {
	// Verify error variables are properly defined
	if ErrGHNotInstalled.Error() != "gh CLI not installed" {
		t.Errorf("ErrGHNotInstalled = %v, want 'gh CLI not installed'", ErrGHNotInstalled)
	}

	if ErrPushFailed.Error() != "failed to push branch" {
		t.Errorf("ErrPushFailed = %v, want 'failed to push branch'", ErrPushFailed)
	}

	if ErrPRCreateFailed.Error() != "failed to create PR" {
		t.Errorf("ErrPRCreateFailed = %v, want 'failed to create PR'", ErrPRCreateFailed)
	}
}
