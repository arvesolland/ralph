package worker

import (
	"errors"
	"os"
	"os/exec"
	"path/filepath"
	"strings"
	"testing"

	"github.com/arvesolland/ralph/internal/git"
	"github.com/arvesolland/ralph/internal/plan"
	"github.com/arvesolland/ralph/internal/worktree"
)

func TestIsGHInstalled(t *testing.T) {
	// This is an existence check - we just verify it returns a boolean
	// and doesn't panic
	result := isGHInstalled()
	// We can't assert the value since it depends on the test environment
	t.Logf("gh installed: %v", result)
}

func TestExtractPRURL(t *testing.T) {
	tests := []struct {
		name     string
		input    string
		expected string
	}{
		{
			name:     "standard URL",
			input:    "https://github.com/arvesolland/ralph/pull/123",
			expected: "https://github.com/arvesolland/ralph/pull/123",
		},
		{
			name:     "URL in text",
			input:    "Created PR: https://github.com/owner/repo/pull/456\nDone.",
			expected: "https://github.com/owner/repo/pull/456",
		},
		{
			name:     "no URL",
			input:    "Something went wrong",
			expected: "",
		},
		{
			name:     "URL with different owner/repo",
			input:    "https://github.com/some-org/some-repo/pull/789",
			expected: "https://github.com/some-org/some-repo/pull/789",
		},
		{
			name:     "multiple URLs (returns first)",
			input:    "First: https://github.com/a/b/pull/1 Second: https://github.com/c/d/pull/2",
			expected: "https://github.com/a/b/pull/1",
		},
		{
			name:     "similar but not PR URL",
			input:    "https://github.com/owner/repo/issues/123",
			expected: "",
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			result := extractPRURL(tt.input)
			if result != tt.expected {
				t.Errorf("extractPRURL(%q) = %q, want %q", tt.input, result, tt.expected)
			}
		})
	}
}

func TestBuildPRBody(t *testing.T) {
	t.Run("basic plan", func(t *testing.T) {
		p := &plan.Plan{
			Name:  "test-feature",
			Tasks: nil,
		}

		body := buildPRBody(p)

		// Verify required elements
		if !strings.Contains(body, "## Summary") {
			t.Error("body should contain Summary header")
		}
		if !strings.Contains(body, "Implements: test-feature") {
			t.Error("body should contain plan name")
		}
		if !strings.Contains(body, "Generated by [Ralph]") {
			t.Error("body should contain Ralph attribution")
		}
	})

	t.Run("plan with tasks", func(t *testing.T) {
		p := &plan.Plan{
			Name: "multi-task",
			Tasks: []plan.Task{
				{Text: "Task 1", Complete: true},
				{Text: "Task 2", Complete: true},
				{Text: "Task 3", Complete: false},
			},
		}

		body := buildPRBody(p)

		// Should include task counts
		if !strings.Contains(body, "Tasks completed: 2/3") {
			t.Errorf("body should contain task counts, got: %s", body)
		}
	})

	t.Run("plan with nested tasks", func(t *testing.T) {
		p := &plan.Plan{
			Name: "nested-tasks",
			Tasks: []plan.Task{
				{
					Text:     "Parent task",
					Complete: true,
					Subtasks: []plan.Task{
						{Text: "Subtask 1", Complete: true},
						{Text: "Subtask 2", Complete: false},
					},
				},
			},
		}

		body := buildPRBody(p)

		// Should count all tasks including subtasks (1 parent + 2 subtasks = 3, 2 complete)
		if !strings.Contains(body, "Tasks completed: 2/3") {
			t.Errorf("body should count nested tasks, got: %s", body)
		}
	})
}

func TestPRURLRegex(t *testing.T) {
	validURLs := []string{
		"https://github.com/owner/repo/pull/1",
		"https://github.com/a/b/pull/123",
		"https://github.com/some-org/some-repo/pull/99999",
	}

	for _, url := range validURLs {
		if !prURLRegex.MatchString(url) {
			t.Errorf("prURLRegex should match %q", url)
		}
	}

	invalidURLs := []string{
		"http://github.com/owner/repo/pull/1", // http not https
		"https://github.com/owner/repo/issues/1",
		"https://github.com/owner/repo/pull/",    // no number
		"https://gitlab.com/owner/repo/pull/123", // not github
	}

	for _, url := range invalidURLs {
		if prURLRegex.MatchString(url) {
			t.Errorf("prURLRegex should not match %q", url)
		}
	}
}

func TestLogManualPRInstructions(t *testing.T) {
	// Just verify it doesn't panic
	p := &plan.Plan{
		Name:   "test-plan",
		Branch: "feat/test-plan",
	}

	// Capture that it runs without error
	logManualPRInstructions(p)
}

// TestCompletePR_Integration tests the full PR completion workflow
// This test requires a real git repository with a remote
func TestCompletePR_Integration(t *testing.T) {
	if testing.Short() {
		t.Skip("skipping integration test in short mode")
	}

	// Check if gh is installed
	if !isGHInstalled() {
		t.Skip("gh CLI not installed, skipping integration test")
	}

	// This test would require:
	// 1. A real git repository with a remote
	// 2. GitHub authentication configured
	// We skip actual PR creation as it would modify real repositories
	t.Skip("full integration test requires real repository setup")
}

// TestPushBranch tests the branch push functionality using a mock
func TestPushBranch(t *testing.T) {
	// Create a mock Git implementation for testing
	mockGit := &mockGitForCompletion{
		pushError: nil,
	}

	err := pushBranch(mockGit, "feat/test")
	if err != nil {
		t.Errorf("pushBranch() error = %v, want nil", err)
	}

	if mockGit.pushedBranch != "feat/test" {
		t.Errorf("pushBranch() pushed branch = %q, want %q", mockGit.pushedBranch, "feat/test")
	}
}

func TestPushBranch_Error(t *testing.T) {
	mockGit := &mockGitForCompletion{
		pushError: ErrPushFailed,
	}

	err := pushBranch(mockGit, "feat/test")
	if err == nil {
		t.Error("pushBranch() should return error when push fails")
	}
}

// mockGitForCompletion is a minimal mock for testing completion functions
type mockGitForCompletion struct {
	git.Git
	pushError    error
	pushedBranch string
	workDir      string
}

func (m *mockGitForCompletion) PushWithUpstream(remote, branch string) error {
	m.pushedBranch = branch
	return m.pushError
}

func (m *mockGitForCompletion) WorkDir() string {
	return m.workDir
}

// TestCreatePR_GHNotInstalled tests graceful handling when gh is not available
func TestCreatePR_GHNotInstalled(t *testing.T) {
	// Temporarily modify PATH to ensure gh is not found
	originalPath := os.Getenv("PATH")
	defer os.Setenv("PATH", originalPath)

	// Set PATH to empty to simulate gh not being installed
	os.Setenv("PATH", "")

	p := &plan.Plan{
		Name:   "test-plan",
		Branch: "feat/test-plan",
	}

	_, err := createPR(p, "/tmp")
	if err != ErrGHNotInstalled {
		t.Errorf("createPR() error = %v, want ErrGHNotInstalled", err)
	}
}

// TestCompletePR_MockGH tests the completion workflow with a mock gh script
func TestCompletePR_MockGH(t *testing.T) {
	if testing.Short() {
		t.Skip("skipping integration test in short mode")
	}

	// Create a temporary directory for the mock gh script
	tmpDir, err := os.MkdirTemp("", "completion-test-*")
	if err != nil {
		t.Fatalf("failed to create temp dir: %v", err)
	}
	defer os.RemoveAll(tmpDir)

	// Create a mock gh script that outputs a PR URL
	mockGH := filepath.Join(tmpDir, "gh")
	mockScript := `#!/bin/bash
echo "https://github.com/test/repo/pull/123"
`
	if err := os.WriteFile(mockGH, []byte(mockScript), 0755); err != nil {
		t.Fatalf("failed to write mock gh: %v", err)
	}

	// Modify PATH to include our mock
	originalPath := os.Getenv("PATH")
	defer os.Setenv("PATH", originalPath)
	os.Setenv("PATH", tmpDir+":"+originalPath)

	// Create a git repo for the worktree
	repoDir := filepath.Join(tmpDir, "repo")
	if err := os.MkdirAll(repoDir, 0755); err != nil {
		t.Fatalf("failed to create repo dir: %v", err)
	}

	// Initialize git repo
	cmd := exec.Command("git", "init")
	cmd.Dir = repoDir
	if err := cmd.Run(); err != nil {
		t.Fatalf("failed to init git repo: %v", err)
	}

	// Create initial commit
	testFile := filepath.Join(repoDir, "test.txt")
	if err := os.WriteFile(testFile, []byte("test"), 0644); err != nil {
		t.Fatalf("failed to write test file: %v", err)
	}

	cmd = exec.Command("git", "add", ".")
	cmd.Dir = repoDir
	if err := cmd.Run(); err != nil {
		t.Fatalf("failed to git add: %v", err)
	}

	cmd = exec.Command("git", "commit", "-m", "initial")
	cmd.Dir = repoDir
	cmd.Env = append(os.Environ(),
		"GIT_AUTHOR_NAME=Test",
		"GIT_AUTHOR_EMAIL=test@test.com",
		"GIT_COMMITTER_NAME=Test",
		"GIT_COMMITTER_EMAIL=test@test.com",
	)
	if err := cmd.Run(); err != nil {
		t.Fatalf("failed to git commit: %v", err)
	}

	// Test plan and worktree
	p := &plan.Plan{
		Name:   "test-feature",
		Branch: "feat/test-feature",
	}
	wt := &worktree.Worktree{
		Path:     repoDir,
		Branch:   "feat/test-feature",
		PlanName: "test-feature",
	}

	// Mock git that succeeds for push
	mockGit := &mockGitForCompletion{
		pushError: nil,
		workDir:   repoDir,
	}

	// Run the PR completion (with our mock gh)
	prURL, err := CompletePR(p, wt, mockGit)
	if err != nil {
		t.Errorf("CompletePR() error = %v", err)
	}

	if prURL != "https://github.com/test/repo/pull/123" {
		t.Errorf("CompletePR() prURL = %q, want %q", prURL, "https://github.com/test/repo/pull/123")
	}
}

func TestCompletionErrors(t *testing.T) {
	// Verify error variables are properly defined
	if ErrGHNotInstalled.Error() != "gh CLI not installed" {
		t.Errorf("ErrGHNotInstalled = %v, want 'gh CLI not installed'", ErrGHNotInstalled)
	}

	if ErrPushFailed.Error() != "failed to push branch" {
		t.Errorf("ErrPushFailed = %v, want 'failed to push branch'", ErrPushFailed)
	}

	if ErrPRCreateFailed.Error() != "failed to create PR" {
		t.Errorf("ErrPRCreateFailed = %v, want 'failed to create PR'", ErrPRCreateFailed)
	}

	if ErrMergeConflict.Error() != "merge conflict" {
		t.Errorf("ErrMergeConflict = %v, want 'merge conflict'", ErrMergeConflict)
	}

	if ErrCheckoutFailed.Error() != "failed to checkout branch" {
		t.Errorf("ErrCheckoutFailed = %v, want 'failed to checkout branch'", ErrCheckoutFailed)
	}

	if ErrMergeFailed.Error() != "failed to merge branch" {
		t.Errorf("ErrMergeFailed = %v, want 'failed to merge branch'", ErrMergeFailed)
	}
}

// mockGitForMerge is a mock Git implementation for testing merge completion
type mockGitForMerge struct {
	git.Git
	checkoutError       error
	mergeError          error
	pushError           error
	deleteBranchError   error
	deleteRemoteError   error
	currentBranch       string
	checkedOutBranch    string
	mergedBranch        string
	deletedBranch       string
	deletedRemoteBranch string
}

func (m *mockGitForMerge) Checkout(branch string) error {
	m.checkedOutBranch = branch
	m.currentBranch = branch
	return m.checkoutError
}

func (m *mockGitForMerge) Merge(branch string, noFastForward bool) error {
	m.mergedBranch = branch
	return m.mergeError
}

func (m *mockGitForMerge) Push() error {
	return m.pushError
}

func (m *mockGitForMerge) DeleteBranch(name string, force bool) error {
	m.deletedBranch = name
	return m.deleteBranchError
}

func (m *mockGitForMerge) DeleteRemoteBranch(remote, branch string) error {
	m.deletedRemoteBranch = branch
	return m.deleteRemoteError
}

func TestCompleteMerge_Success(t *testing.T) {
	p := &plan.Plan{
		Name:   "test-feature",
		Branch: "feat/test-feature",
	}

	mock := &mockGitForMerge{}
	err := CompleteMerge(p, "main", mock)
	if err != nil {
		t.Errorf("CompleteMerge() error = %v, want nil", err)
	}

	if mock.checkedOutBranch != "main" {
		t.Errorf("should checkout base branch, got %q", mock.checkedOutBranch)
	}

	if mock.mergedBranch != "feat/test-feature" {
		t.Errorf("should merge feature branch, got %q", mock.mergedBranch)
	}

	if mock.deletedBranch != "feat/test-feature" {
		t.Errorf("should delete local feature branch, got %q", mock.deletedBranch)
	}

	if mock.deletedRemoteBranch != "feat/test-feature" {
		t.Errorf("should delete remote feature branch, got %q", mock.deletedRemoteBranch)
	}
}

func TestCompleteMerge_CheckoutFails(t *testing.T) {
	p := &plan.Plan{
		Name:   "test-feature",
		Branch: "feat/test-feature",
	}

	mock := &mockGitForMerge{
		checkoutError: git.ErrBranchNotFound,
	}

	err := CompleteMerge(p, "main", mock)
	if err == nil {
		t.Error("CompleteMerge() should return error when checkout fails")
	}

	if !strings.Contains(err.Error(), "failed to checkout") {
		t.Errorf("error should mention checkout failure, got: %v", err)
	}
}

func TestCompleteMerge_MergeConflict(t *testing.T) {
	p := &plan.Plan{
		Name:   "test-feature",
		Branch: "feat/test-feature",
	}

	mock := &mockGitForMerge{
		mergeError: git.ErrMergeConflict,
	}

	err := CompleteMerge(p, "main", mock)
	if err == nil {
		t.Error("CompleteMerge() should return error on merge conflict")
	}

	if !strings.Contains(err.Error(), "merge conflict") {
		t.Errorf("error should mention merge conflict, got: %v", err)
	}
}

func TestCompleteMerge_MergeFails(t *testing.T) {
	p := &plan.Plan{
		Name:   "test-feature",
		Branch: "feat/test-feature",
	}

	mock := &mockGitForMerge{
		mergeError: errors.New("some git error"),
	}

	err := CompleteMerge(p, "main", mock)
	if err == nil {
		t.Error("CompleteMerge() should return error on merge failure")
	}

	if !strings.Contains(err.Error(), "failed to merge") {
		t.Errorf("error should mention merge failure, got: %v", err)
	}
}

func TestCompleteMerge_PushFails(t *testing.T) {
	p := &plan.Plan{
		Name:   "test-feature",
		Branch: "feat/test-feature",
	}

	mock := &mockGitForMerge{
		pushError: errors.New("push rejected"),
	}

	err := CompleteMerge(p, "main", mock)
	if err == nil {
		t.Error("CompleteMerge() should return error on push failure")
	}

	if !strings.Contains(err.Error(), "failed to push") {
		t.Errorf("error should mention push failure, got: %v", err)
	}
}

func TestCompleteMerge_DeleteBranchFails(t *testing.T) {
	p := &plan.Plan{
		Name:   "test-feature",
		Branch: "feat/test-feature",
	}

	mock := &mockGitForMerge{
		deleteBranchError: errors.New("branch in use"),
	}

	// Should NOT fail - just log warning
	err := CompleteMerge(p, "main", mock)
	if err != nil {
		t.Errorf("CompleteMerge() should not fail when branch delete fails, got: %v", err)
	}
}

func TestCompleteMerge_DeleteRemoteBranchFails(t *testing.T) {
	p := &plan.Plan{
		Name:   "test-feature",
		Branch: "feat/test-feature",
	}

	mock := &mockGitForMerge{
		deleteRemoteError: errors.New("remote branch not found"),
	}

	// Should NOT fail - just log warning
	err := CompleteMerge(p, "main", mock)
	if err != nil {
		t.Errorf("CompleteMerge() should not fail when remote branch delete fails, got: %v", err)
	}
}

// TestCompleteMerge_Integration tests the full merge workflow with real git
func TestCompleteMerge_Integration(t *testing.T) {
	if testing.Short() {
		t.Skip("skipping integration test in short mode")
	}

	// Create temporary directory for test repo
	tmpDir, err := os.MkdirTemp("", "merge-test-*")
	if err != nil {
		t.Fatalf("failed to create temp dir: %v", err)
	}
	defer os.RemoveAll(tmpDir)

	repoDir := filepath.Join(tmpDir, "repo")
	if err := os.MkdirAll(repoDir, 0755); err != nil {
		t.Fatalf("failed to create repo dir: %v", err)
	}

	// Initialize git repo
	runGit := func(args ...string) {
		cmd := exec.Command("git", args...)
		cmd.Dir = repoDir
		cmd.Env = append(os.Environ(),
			"GIT_AUTHOR_NAME=Test",
			"GIT_AUTHOR_EMAIL=test@test.com",
			"GIT_COMMITTER_NAME=Test",
			"GIT_COMMITTER_EMAIL=test@test.com",
		)
		if output, err := cmd.CombinedOutput(); err != nil {
			t.Fatalf("git %v failed: %v\n%s", args, err, output)
		}
	}

	runGit("init", "-b", "main")

	// Create initial commit on main
	testFile := filepath.Join(repoDir, "test.txt")
	if err := os.WriteFile(testFile, []byte("initial"), 0644); err != nil {
		t.Fatalf("failed to write test file: %v", err)
	}
	runGit("add", ".")
	runGit("commit", "-m", "initial commit")

	// Create feature branch with a commit
	runGit("checkout", "-b", "feat/test-feature")
	if err := os.WriteFile(testFile, []byte("feature change"), 0644); err != nil {
		t.Fatalf("failed to write test file: %v", err)
	}
	runGit("add", ".")
	runGit("commit", "-m", "feature commit")

	// Switch back to main for the merge
	runGit("checkout", "main")

	// Test plan
	p := &plan.Plan{
		Name:   "test-feature",
		Branch: "feat/test-feature",
	}

	// Create Git instance for the repo
	g := git.NewGit(repoDir)

	// Run merge completion (skip push since no remote)
	// We'll just verify checkout and merge work
	err = g.Checkout("main")
	if err != nil {
		t.Fatalf("checkout failed: %v", err)
	}

	err = g.Merge("feat/test-feature", true)
	if err != nil {
		t.Fatalf("merge failed: %v", err)
	}

	// Verify the file has feature changes
	content, err := os.ReadFile(testFile)
	if err != nil {
		t.Fatalf("failed to read test file: %v", err)
	}

	if string(content) != "feature change" {
		t.Errorf("file content = %q, want %q", string(content), "feature change")
	}

	// Verify feature branch can be deleted
	err = g.DeleteBranch("feat/test-feature", true)
	if err != nil {
		t.Errorf("delete branch failed: %v", err)
	}

	// Verify branch no longer exists
	exists, err := g.BranchExists("feat/test-feature")
	if err != nil {
		t.Fatalf("branch exists check failed: %v", err)
	}
	if exists {
		t.Error("feature branch should be deleted")
	}

	t.Logf("Successfully merged %s into main", p.Branch)
}
